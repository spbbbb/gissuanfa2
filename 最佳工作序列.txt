//从给定的数组中找到利润最大的作业序列，有最后期限、利润和花费时间的工作
#include<iostream>
#include<algorithm>
#define min(a,b) ((a)<(b))?(a):(b)

using namespace std;

// Job的结构
struct Job
{
   char id;      // 工作 Id
   int dead;    // 工作的deadline
   int profit; // 在deadline之前完成时，工作的获利
   int cost;  // 工作的cost
};
 
 
// 此函数用于根据利润对所有作业进行排序
bool comparison(Job a, Job b)
{
	if(a.profit!=b.profit)
		return (a.profit > b.profit);
	else
		return (a.dead < b.dead);
}
 
//返回平台所需的最小数目
void printJobScheduling(Job arr[], int n, int max)
{
    // 根据prfit的递减顺序对所有作业进行排序
	sort(arr, arr+n, comparison);

	int* result = new int[n]; // 存储结果(作业序列)
    bool* slot = new bool[max];  // 跟踪空闲时间
	int r=0;
 
    // 初始化所有位置为空闲
    for (int i=0; i<max; i++)
        slot[i] = false;
 
    // 遍历所有给定的作业
    for (i=0; i<n; i++)
	{
		int sum_cost=0;
		//已排好的工作消耗的时间和
		if(i>0)
		{
			for(int k=0; k<i; k++)
			{
				sum_cost=sum_cost+arr[k].cost;
			}
		}

		//判断添加的任务是否会与之前任务发生冲突，没有问题则将结果放入result中，标记已占用的时间单位
		if(slot[sum_cost]==false && sum_cost+arr[i].cost<=arr[i].dead)
		{
			result[r]=i;
			r++;
			for(int j=sum_cost; j<sum_cost+arr[i].cost; j++)
			{
				slot[j] = true;
			}
		}
	}


    // 输出答案
    for (i=0; i<n; i++)
       if (slot[i])
         cout << arr[result[i]].id << " ";
}

int main()
{
	//依次为id, dead, profit, cost
	Job arr[] = { {'a', 10, 2, 4}, {'b', 8, 3, 3}, {'c', 4, 3, 2},{'d', 2, 6, 1}};
	//确定工作个数
    int n = sizeof(arr)/sizeof(arr[0]);
	//算出所需的最大时间空间
	int max=arr[0].dead;
	for (int i=0;i<n;i++)
		if(max<arr[i].dead)
			max=arr[i].dead;
	//输出结果
    cout << "Following is maximum profit sequence of jobs\n";
    printJobScheduling(arr, n, max);
    return 0;
}